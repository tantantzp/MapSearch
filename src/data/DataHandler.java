package data;import data.PrefixTrie;import data.KdTree.Entry;import data.KdTree.SqrEuclid;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import java.util.Vector;import net.sf.json.JSONArray;import net.sf.json.JSONObject;public class DataHandler {	public double[] centerLoc = null;	Vector<JSONObject> dataVec = null;	PrefixTrie prefixTrie = null;	public DataHandler(String filePath){		centerLoc = new double[2];		centerLoc[0] = 1.281933;		centerLoc[1] = 103.80321;			dataVec = new Vector<JSONObject>();		prefixTrie = new PrefixTrie();				readFile(filePath);	}		public void readFile(String filePath){		try {			BufferedReader in = new BufferedReader(new FileReader(new File(filePath)));		    String line = null;						while((line = in.readLine())!=null){				JSONObject jData = JSONObject.fromObject(line);				dataVec.add(jData);			}						in.close();					} catch (FileNotFoundException e1) {			e1.printStackTrace();		} catch (IOException e) {			e.printStackTrace();		}		buildupData();		System.out.println("build data finish.");		}		public void setCenter(double[] location){		centerLoc = location;	}		public void buildupData(){		for(int i=0; i<dataVec.size(); i++){			JSONObject data = dataVec.get(i);			String dataStr = data.getString("addr") + " " + data.getString("name");			String grams[] = dataStr.split("[\\s]");						for(int j=0; j<grams.length; j++){				prefixTrie.addGram(grams[j], i);			}		}	}		public List<Entry<JSONObject>> searchQuery(String query){		String [] frefixGrams = query.split("[\\s]");		Set<Integer> candidates = null;				//search candidates using prefixTrie		for(int i=0; i<frefixGrams.length; i++){			Set<Integer> tCandidates  = prefixTrie.prefixSearch(frefixGrams[i]);			if(tCandidates == null) return null;			if(candidates == null)				candidates = tCandidates;			else				candidates.retainAll(tCandidates);		}		//build kdtree for the candidates		SqrEuclid<JSONObject> tKdTree = new SqrEuclid<>(2, candidates.size()+100);		for (Integer index : candidates){			JSONObject jsonCandi = dataVec.get(index);			JSONArray jsonLoc = (JSONArray)jsonCandi.get("latlng");			double[] location = new double[2];			location[0] = jsonLoc.getDouble(0);			location[1] = jsonLoc.getDouble(1);			tKdTree.addPoint(location, jsonCandi);		}				//find nearest points using the kdtree		List<Entry<JSONObject>> result = tKdTree.nearestNeighbor(centerLoc, 10, true);		Collections.reverse(result);		return result;	}		public String createHTMLTable(List<Entry<JSONObject>> data) {		String rowPattern = "<tr>\ndata</tr>\n";		String colPattern = "<td>\ndata</td>\n";		String result = "<table border=\"1\">\n";		if (data == null || data.size() < 1) {			result += "No match results";		} else {			String line = "";			line += colPattern.replace("data","pcode");				line += colPattern.replace("data","name");							line += colPattern.replace("data","address");			result += rowPattern.replace("data", line);			for (Entry<JSONObject> entry : data) {				line = "";				JSONArray ja = (JSONArray) entry.value.get("latlng");				line += colPattern.replace("data",						entry.value.getString("pcode"));				line += colPattern.replace("data",						entry.value.getString("name"));								line += colPattern.replace("data",						entry.value.getString("addr"));				result += rowPattern.replace("data", line);			}		}		result += "</table>\n";		return result;	}}